# 内部类

将一个类设计成内部类，我觉得有两方面因素：

1. 在一个类内部，需要操作某种属性，而这个属性需要涉及的面又很广，我们可以考虑，将这些属性设计为内部类。

2. 然后就如下面 [铁心男](https://www.zhihu.com/people/tie-xin-nan) 用户回答的那样，好比你设计类 B 的目的只是为了给类 A 使用，那么，我们就可将其设定为内部类，没有必要将类 B 设置成单独的 Java 文件，防止与其他类产生依赖关系。

然后我们再来说说为什么又将内部类设计为静态内部类与内部类：

1. 首先来看一下静态内部类的特点：如 [昭言](https://www.zhihu.com/people/hujf) 用户所述那样，我是静态内部类，只不过是想借你的外壳用一下。本身来说，我和你没有什么“强依赖”上的关系。没有你，我也可以创建实例。那么，在设计内部类的时候我们就可以做出权衡：如果我内部类与你外部类关系不紧密，耦合程度不高，不需要访问外部类的所有属性或方法，那么我就设计成静态内部类。而且，由于静态内部类与外部类并不会保存相互之间的引用，因此在一定程度上，还会节省那么一点内存资源，何乐而不为呢~~

2. 既然上面已经说了什么时候应该用静态内部类，那么如果你的需求不符合静态内部类所提供的一切好处，你就应该考虑使用内部类了。最大的特点就是：你在内部类中需要访问有关外部类的所有属性及方法，我知晓你的一切... ... 

总结：首先需要知道为什么会有内部类，什么时候应该使用内部类，我们再去讨论，为什么 Java 的设计者们又将内部类设计为静态与非静态，这样就很清晰了。

## 内部类加载时机

无论是静态内部类还是普通内部类，都是在第一次用的时候加载。如果直接访问静态内部类，则外部类不会加载。

## 局部内部类

写在方法或者代码段中的内部类（包括匿名内部类）。

局部内部类为什么只能访问final局部变量，对于成员变量却可以随便访问？

局部变量和成员变量对于内部类而言，具有一定的共性，都是该内部类外面的变量。如果要求内部类只能访问final的局部变量是为了确保局部变量不被修改的话，那么内部类访问成员变量应该也有类似的限制才对

我认为是由于他们的存活范围导致了这个区别：

1. 首先内部类的实例可以在方法结束后依然存活，局部变量在方法结束后却无法存活。

   局部内部类对象不因为它本身在方法中而被存放在虚拟机栈中，它实际上是存放在堆中的，因为在javac编译的时候，内部类是Outer$Inner.class，是一个独立的文件，所以在方法结束后，它不会被立即回收。而局部变量在栈帧中，随着方法执行完而出栈，被回收掉。如果局部内部类对象访问不是final的局部变量，那么就存在使用已经消失的变量的情况，这很不安全。多线程中就很容易出现这样的问题，举例：

   ~~~java
   public class Outer {
       public void function(){
           int finalI = 0;
           //finalI++;
           new Thread(
               // 可能function结束，出栈了。这个Runnable线程类实例才刚跑起来，从而访问了消失的finalI。不过在Java8中，没有改变的局部变量，并且被匿名内部类访问了，会自动被加上final。但是如果finalI++了，那么这个自动加final就失效了，需要手动拷贝一份。
               () -> {
               	System.out.println(finalI);
           	}
           ).start();
       }
   }
   ~~~

   而成员变量的存活时间是取决于外部类的实例的，内部类实例中都会强引用当前外部类实例，所以当内部类对象还存活的时候，外部类对象就肯定还活着（outer = null; 只是outer指向了null，实例还在堆中没回收呢），所以内部类实例可以访问外部内的属性。 

2. 剩下的问题是，为什么可以访问final的局部变量呢？如果将一个访问了final的局部变量的内部类进行反编译，可以发现该变量是被作为构造函数的参数传入进去的，与之一起传入的参数还有外部类实例。既然javac是这样处理内部类的，那么这与为内部类提供一个带参数的构造函数就没什么两样了！并且，使用final修饰之后，该局部变量就被存放在堆中了，所以可以访问。


### 关于Stream的分析

stream笔记中map方法那段关于内部类的说法不全。其本质呢就是new了一个对象，然后把mapper当参数封装进去，返回而已。在某一方法中，局部内部类访问局部变量因为生命周期问题，局部变量确实要变成final，它有这样的生命周期（与类的生命周期相同）才能在编译层面作为局部内部类的成员变量。如上，内部类就是把mapper当作成员变量在使，自身并没有定义这样一个成员变量，所以需要final修饰然后在编译层面复制给内部类。至于在该方法中，new其他对象并且这个对象使用到该方法的局部变量，仅仅只是使用了局部变量的值，成员变量还是对象自己的成员变量，所以不需要把局部变量变成final。

### 参考资料

[Java内部类详解](https://www.cnblogs.com/dolphin0520/p/3811445.html)

